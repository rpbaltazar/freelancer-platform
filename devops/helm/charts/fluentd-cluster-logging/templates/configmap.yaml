{{- if eq .Values.logSink.type "gcp" -}}
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ include "fluentd-cluster-logging.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "fluentd-cluster-logging.name" . }}
    helm.sh/chart: {{ include "fluentd-cluster-logging.chart" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
data:
  containers.input.conf: |-
    # This configuration file for Fluentd is used
    # to watch changes to Docker log files that live in the
    # directory /var/lib/docker/containers/ and are symbolically
    # linked to from the /var/log/containers directory using names that capture the
    # pod name and container name. These logs are then submitted to
    # Google Cloud Logging which assumes the installation of the cloud-logging plug-in.
    #
    # Example
    # =======
    # A line in the Docker log file might look like this JSON:
    #
    # {"log":"2014/09/25 21:15:03 Got request with path wombat\\n",
    #  "stream":"stderr",
    #   "time":"2014-09-25T21:15:03.499185026Z"}
    #
    # The record reformer is used to write the tag to focus on the pod name
    # and the Kubernetes container name. For example a Docker container's logs
    # might be in the directory:
    #  /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b
    # and in the file:
    #  997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
    # where 997599971ee6... is the Docker ID of the running container.
    # The Kubernetes kubelet makes a symbolic link to this file on the host machine
    # in the /var/log/containers directory which includes the pod name and the Kubernetes
    # container name:
    #    synthetic-logger-0.25lps-pod_default-synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    #    ->
    #    /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
    # The /var/log directory on the host is mapped to the /var/log directory in the container
    # running this instance of Fluentd and we end up collecting the file:
    #   /var/log/containers/synthetic-logger-0.25lps-pod_default-synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    # This results in the tag:
    #  var.log.containers.synthetic-logger-0.25lps-pod_default-synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    # The record reformer is used is discard the var.log.containers prefix and
    # the Docker container ID suffix and "kubernetes." is pre-pended giving the tag:
    #   kubernetes.synthetic-logger-0.25lps-pod_default-synth-lgr
    # Tag is then parsed by google_cloud plugin and translated to the metadata,
    # visible in the log viewer

    # Example:
    # {"log":"[info:2016-02-16T16:04:05.930-08:00] Some log text here\n","stream":"stdout","time":"2016-02-17T00:04:05.931087621Z"}
    <source>
      @type tail
      format json
      time_key time
      path /var/log/containers/*.log
      pos_file /var/log/gcp-containers.log.pos
      time_format %Y-%m-%dT%H:%M:%S.%N%Z
      tag reform.*
      read_from_head true
    </source>

    <filter reform.**>
      @type kubernetes_metadata
    </filter>

    <filter reform.**>
      @type record_modifier
      remove_keys kubernetes,docker,stream,_dummy_
      <record>
        # trick to set severity to ERROR for stderr stream
        _dummy_ ${if record['stream'] == 'stderr'; record["severity"] = 'ERROR'; end; nil}
        logging.googleapis.com/local_resource_id k8s_container.${record["kubernetes"]["namespace_name"]}.${record["kubernetes"]["pod_name"]}.${record["kubernetes"]["container_name"]}
      </record>
    </filter>

    <match reform.**>
      @type record_reformer
      enable_ruby true
      tag raw.kubernetes.${tag_suffix[4].split('-')[0..-2].join('-')}
    </match>

    # Detect exceptions in the log output and forward them as one log entry.
    <match raw.kubernetes.**>
      @type copy

      <store>
        @type prometheus

        <metric>
          type counter
          name logging_line_count
          desc Total number of lines generated by application containers
          <labels>
            tag ${tag}
          </labels>
        </metric>
      </store>
      <store>
        @type detect_exceptions

        remove_tag_prefix raw
        message log
        stream stream
        multiline_flush_interval 5
        max_bytes 500000
        max_lines 1000
      </store>
    </match>
  system.input.conf: |-
    <source>
      @type tail
      format syslog
      path /var/log/cloud-init.log
      pos_file /var/log/cloud-init.log.pos
      tag cloud-init
    </source>

    <source>
      @type tail
      format syslog
      path /var/log/cloud-init-output.log
      pos_file /var/log/cloud-init-output.log.pos
      tag cloud-init-output
    </source>

    # Multi-line parsing is required for all the kube logs because very large log
    # statements, such as those that include entire object bodies, get split into
    # multiple lines by glog.

    # Example:
    # I0204 07:32:30.020537    3368 server.go:1048] POST /stats/container/: (13.972191ms) 200 [[Go-http-client/1.1] 10.244.1.3:40537]
    <source>
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kubelet.log
      pos_file /var/log/kubelet.log.pos
      tag kubelet
    </source>

    # Example:
    # I1118 21:26:53.975789       6 proxier.go:1096] Port "nodePort for kube-system/default-http-backend:http" (:31429/tcp) was open before and is still needed
    <source>
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kube-proxy.log
      pos_file /var/log/kube-proxy.log.pos
      tag kube-proxy
    </source>

    # Logs from systemd-journal for interesting services.
    <source>
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "docker.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/journald-docker.pos
      </storage>
      read_from_head true
      tag docker
    </source>

    <source>
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "kubelet.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/journald-kubelet.pos
      </storage>
      read_from_head true
      tag kubelet
    </source>
  monitoring.conf: |-
    # Prometheus monitoring
    <source>
      @type prometheus
      port 24231
    </source>

    <source>
      @type prometheus_monitor
    </source>
  output.conf: |-
    # We use 2 output stanzas - one to handle the container logs and one to handle
    # the node daemon logs, the latter of which explicitly sends its logs to the
    # compute.googleapis.com service rather than container.googleapis.com to keep
    # them separate since most users don't care about the node logs.
    <match kubernetes.**>
      @type copy

      <store>
        @type google_cloud
        
        # turn off use_metadata_service will set platform to Platform::OTHER
        use_metadata_service false
        enable_metadata_agent false

        k8s_cluster_name "{{ .Values.clusterName }}"
        k8s_cluster_location "{{ .Values.clusterLocation }}"
        
        zone "{{ .Values.clusterLocation }}"
        vm_id "other"
        detect_json true
        use_grpc true

        # Set the buffer type to file to improve the reliability and reduce the memory consumption
        buffer_type file
        buffer_path /var/log/fluentd-buffers/kubernetes.containers.buffer
        # Set queue_full action to block because we want to pause gracefully
        # in case of the off-the-limits load instead of throwing an exception
        buffer_queue_full_action block
        # Set the chunk limit conservatively to avoid exceeding the GCL limit
        # of 10MiB per write request.
        buffer_chunk_limit 2M
        # Cap the combined memory usage of this buffer and the one below to
        # 2MiB/chunk * (6 + 2) chunks = 16 MiB
        buffer_queue_limit 6
        # Never wait more than 5 seconds before flushing logs in the non-error case.
        flush_interval 5s
        # Never wait longer than 30 seconds between retries.
        max_retry_wait 30
        # Disable the limit on the number of retries (retry forever).
        disable_retry_limit
        # Use multiple threads for processing.
        num_threads 2
      </store>
      <store>
        @type prometheus

        <metric>
          type counter
          name logging_entry_count
          desc Total number of log entries generated by either an application container or a system component
          <labels>
            tag ${tag}
            component container
          </labels>
        </metric>
      </store>
    </match>

    # for k8s_node
    <filter **>
      @type record_modifier
      enable_ruby true
      <record>
        logging.googleapis.com/local_resource_id k8s_node.${ENV["K8S_NODE_NAME"].split('.')[0]}
      </record>
    </filter>
    
    # Keep a smaller buffer here since these logs are less important than the user's
    # container logs.
    <match **>
      @type copy

      <store>
        @type google_cloud

        use_metadata_service false
        enable_metadata_agent false
        detect_subservice false
        
        k8s_cluster_name "{{ .Values.clusterName }}"
        k8s_cluster_location "{{ .Values.clusterLocation }}"
        
        zone "{{ .Values.clusterLocation }}"
        vm_id "other"
        
        use_grpc true
        buffer_type file
        buffer_path /var/log/fluentd-buffers/kubernetes.system.buffer
        buffer_queue_full_action block
        buffer_chunk_limit 2M
        buffer_queue_limit 2
        flush_interval 5s
        max_retry_wait 30
        disable_retry_limit
        num_threads 2
      </store>
      <store>
        @type prometheus

        <metric>
          type counter
          name logging_entry_count
          desc Total number of log entries generated by either an application container or a system component
          <labels>
            tag ${tag}
            component system
          </labels>
        </metric>
      </store>
    </match>
{{- end -}}

{{- if eq .Values.logSink.type "s3" -}}
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ include "fluentd-cluster-logging.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "fluentd-cluster-logging.name" . }}
    helm.sh/chart: {{ include "fluentd-cluster-logging.chart" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
data:
  containers.input.conf: |-
    # This configuration file for Fluentd is used
    # to watch changes to Docker log files that live in the
    # directory /var/lib/docker/containers/ and are symbolically
    # linked to from the /var/log/containers directory using names that capture the
    # pod name and container name. These logs are then submitted to
    # Google Cloud Logging which assumes the installation of the cloud-logging plug-in.
    #
    # Example
    # =======
    # A line in the Docker log file might look like this JSON:
    #
    # {"log":"2014/09/25 21:15:03 Got request with path wombat\\n",
    #  "stream":"stderr",
    #   "time":"2014-09-25T21:15:03.499185026Z"}
    #
    # The record reformer is used to write the tag to focus on the pod name
    # and the Kubernetes container name. For example a Docker container's logs
    # might be in the directory:
    #  /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b
    # and in the file:
    #  997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
    # where 997599971ee6... is the Docker ID of the running container.
    # The Kubernetes kubelet makes a symbolic link to this file on the host machine
    # in the /var/log/containers directory which includes the pod name and the Kubernetes
    # container name:
    #    synthetic-logger-0.25lps-pod_default-synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    #    ->
    #    /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
    # The /var/log directory on the host is mapped to the /var/log directory in the container
    # running this instance of Fluentd and we end up collecting the file:
    #   /var/log/containers/synthetic-logger-0.25lps-pod_default-synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    # This results in the tag:
    #  var.log.containers.synthetic-logger-0.25lps-pod_default-synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    # The record reformer is used is discard the var.log.containers prefix and
    # the Docker container ID suffix and "kubernetes." is pre-pended giving the tag:
    #   kubernetes.synthetic-logger-0.25lps-pod_default-synth-lgr
    # Tag is then parsed by google_cloud plugin and translated to the metadata,
    # visible in the log viewer

    # Example:
    # {"log":"[info:2016-02-16T16:04:05.930-08:00] Some log text here\n","stream":"stdout","time":"2016-02-17T00:04:05.931087621Z"}
    <source>
      @type tail
      format json
      time_key time
      path /var/log/containers/*.log
      pos_file /var/log/{{ include "fluentd-cluster-logging.name" . }}-containers.log.pos
      time_format %Y-%m-%dT%H:%M:%S.%N%Z
      tag reform.*
      read_from_head true
    </source>

    <filter reform.**>
      @type kubernetes_metadata
    </filter>

    <match reform.**>
      @type record_reformer
      remove_keys kubernetes,docker,stream
      enable_ruby true
      tag raw.kubernetes.${record["kubernetes"]["namespace_name"]}/${record["kubernetes"]["pod_name"]}/${record["kubernetes"]["container_name"]}
    </match>

    # Detect exceptions in the log output and forward them as one log entry.
    <match raw.kubernetes.**>
      @type copy

      <store>
        @type prometheus

        <metric>
          type counter
          name logging_line_count
          desc Total number of lines generated by application containers
          <labels>
            tag ${tag}
          </labels>
        </metric>
      </store>
      <store>
        @type detect_exceptions

        remove_tag_prefix raw
        message log
        stream stream
        multiline_flush_interval 5
        max_bytes 500000
        max_lines 1000
      </store>
    </match>
  system.input.conf: |-
    <source>
      @type tail
      format syslog
      path /var/log/cloud-init.log
      pos_file /var/log/{{ include "fluentd-cluster-logging.name" . }}-cloud-init.log.pos
      tag cloud-init
    </source>

    <source>
      @type tail
      format syslog
      path /var/log/cloud-init-output.log
      pos_file /var/log/{{ include "fluentd-cluster-logging.name" . }}-cloud-init-output.log.pos
      tag cloud-init-output
    </source>

    # Multi-line parsing is required for all the kube logs because very large log
    # statements, such as those that include entire object bodies, get split into
    # multiple lines by glog.

    # Example:
    # I0204 07:32:30.020537    3368 server.go:1048] POST /stats/container/: (13.972191ms) 200 [[Go-http-client/1.1] 10.244.1.3:40537]
    <source>
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kubelet.log
      pos_file /var/log/{{ include "fluentd-cluster-logging.name" . }}-kubelet.log.pos
      tag kubelet
    </source>

    # Example:
    # I1118 21:26:53.975789       6 proxier.go:1096] Port "nodePort for kube-system/default-http-backend:http" (:31429/tcp) was open before and is still needed
    <source>
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kube-proxy.log
      pos_file /var/log/{{ include "fluentd-cluster-logging.name" . }}-kube-proxy.log.pos
      tag kube-proxy
    </source>

    # Logs from systemd-journal for interesting services.
    <source>
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "docker.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/{{ include "fluentd-cluster-logging.name" . }}-journald-docker.pos
      </storage>
      read_from_head true
      tag docker
    </source>

    <source>
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "kubelet.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/{{ include "fluentd-cluster-logging.name" . }}-journald-kubelet.pos
      </storage>
      read_from_head true
      tag kubelet
    </source>
  monitoring.conf: |-
    # Prometheus monitoring
    <source>
      @type prometheus
      port 24231
    </source>

    <source>
      @type prometheus_monitor
    </source>
  output.conf: |-
    # We use 2 output stanzas - one to handle the container logs and one to handle
    # the node daemon logs
    <match **>
      @type copy

      <store>
        @type s3
        {{- if .Values.logSink.use_ec2_instance_profile }}
        <instance_profile_credentials>
        </instance_profile_credentials>
        {{- else if and .Values.logSink.aws_access_key_id .Values.logSink.aws_secret_access_key }}
        aws_key_id {{ .Values.logSink.aws_access_key_id }}
        aws_sec_key {{ .Values.logSink.aws_secret_access_key }}
        {{- end }}

        s3_bucket {{ .Values.logSink.s3_bucket }}
        s3_region {{ .Values.logSink.s3_region }}
        {{- with .Values.logSink.s3_endpoint }}
        s3_endpoint {{ . }}
        {{- end }}

        store_as json
        s3_object_key_format "{{ .Values.logSink.s3_prefix }}{{ .Values.clusterName }}/${tag}/dt=%Y-%m-%d-%H-%M/%{index}.%{file_extension}"

        <buffer tag,time>
          @type file
          path /var/log/fluent/{{ include "fluentd-cluster-logging.name" . }}-s3
          timekey 1m
          timekey_wait 1m
          timekey_use_utc true
        </buffer>

        <format>
          @type json
        </format>
      </store>

      <store>
        @type prometheus

        <metric>
          type counter
          name logging_entry_count
          desc Total number of log entries generated by either an application container or a system component
          <labels>
            tag ${tag}
            component container
          </labels>
        </metric>
      </store>
    </match>
{{- end -}}
